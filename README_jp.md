Vectorblox ORCA
================

ORCAは、RISC-Vの実装です。FPGAをターゲットとしており、RV32IとRV32IMの両方のコアとして構成することができます。
RV32IおよびRV32IMのいずれかのコアとして構成されます。

ORCAは、スタンドアロン・プロセッサとして使用できますが、Vectorblox社独自のLightweight Vector Extensions (LV)のホストとして使用するために構築されています。
Vectorblox社独自のLVE（Lightweight Vector Extensions）または本格的な
Matrix processor [MXP](https://github.com/VectorBlox/mxp)のホストとして構築されています。

オプションのAXI3/4命令キャッシュとデータキャッシュ、未キャッシュトランザクション用の独立したAXI4-Liteインターフェイスを備えています。
として構成できる補助インターフェイスを備えています。
WISHBONE, Intel Avalon, Xilinx LMB のいずれかに設定できる補助インターフェイスを備えています。

インテルツールチェーンに簡単に統合できるよう、Qsysコンポーネントが提供されています。
また、ザイリンクスとの統合のためにVivado IPIコンポーネントが提供されています。


Building Toolchain
-----------------

To build the toolchain, set `RISCV_INSTALL` to be the destination directory for
the toolchain, for instance `/opt/riscv/`, then run
`GIT_TOP/tools/riscv-toolchain/build-toolchain.sh`.

Sample Systems
--------------

異なるベンダーのプラットフォーム用のサンプルプロジェクトが、systems/
サブディレクトリにあります。

zedboard ディレクトリには、Zynq-7000 XC7Z020-CLG484-1 SoC を使用した Zeboard 開発ボードをターゲットとする Xilinx Vivado サンプル プロジェクトがあります。
Zynq-7000 XC7Z020-CLG484-1 SoC を使用した Zeboard 開発ボードをターゲットとするサンプル プロジェクトが含まれています。

de2-115 ディレクトリーには、DE2-115 をターゲットとする Intel Qsys/Quartus プロジェクトが含まれています。
DE2-115 (TPad または Veek 開発システム) をターゲットにした Intel Qsys/Quartus プロジェクトが含まれています。

これらのサンプルシステムに加えて、デバッグや自動テストに使用するシステム（simディレクトリ内）も提供しています。
Modelsimを使用したデバッグや自動テストに使用するためのシステムです。  弊社では、Intel Qsysを使用して、これらのシステムの保守とインターコネクトの生成を支援しています。
これらのシステムを維持し、相互接続を生成するために、Intel Qsysを使用しています。  サンプル・システムは、必要に応じて完全にシミュレートすることができます。
各ディレクトリにあるREADMEを参照してください。
詳細については、各ディレクトリのREADMEを参照してください。


ORCA Core Generics
----------------

以下は、ORCAコアを構成するためにトップレベルから公開される様々なジェネリックの概要です。
ORCAコアを構成するためにトップ・レベルから公開される様々なジェネリックの概要です（ORCA外部メモリ・インターフェースのジェネリックについては、以下の別のセクションで説明します）。
別のセクションで説明します）。  Intel Quartus/QsysまたはXilinx Vivadoを使用している場合、ジェネリックの設定を簡略化するグラフィカル・インターフェースがあります。
ジェネリックの設定を簡略化するグラフィカル・インターフェースが提供されています。

### REGISTER_SIZE`(デフォルト=32)

将来のRV64サポート用に予約されています。現在、32の値のみがサポートされています。

現在、32の値しかサポートされていません） ### `RESET_VECTOR` （デフォルト = 0x0000 0000

リセット時に最初に実行される命令が配置されるアドレスです。

### `INTERRUPT_VECTOR` (デフォルト = 0x0000 0200)

mtvec`レジスタのリセット値です。このレジスタは、マシントラップ時に実行される最初の命令のアドレスを定義しています。
このレジスタは、マシントラップ（すなわち、割り込みと例外）で最初に実行される命令のアドレスを定義します。
例外）において最初に実行される命令のアドレスを定義するレジスタです。mtvec`の値は、リセット後にソフトウェアで変更することができます。

### MAX_IFETCHES_IN_FLIGHT` (デフォルト=1)

サポートされる飛行中の未処理命令フェッチの数。
より高い数は、より多くの領域を使用しますが、命令RAMへの遅延が複数サイクルある場合、より多くのスループットを得ることができます。
命令RAMに複数サイクルの遅延がある場合、より多くの領域を使用しますが、より多くのスループットを得ることができます。

### BTB_ENTRIES`(デフォルト=0)

ブランチターゲットバッファ（BTB）エントリーの数です。  0に設定すると、分岐予測は行われません。
予測は行われません（すべての枝が予測され、取られていないことと同じです）。  1以上に設定された場合
に設定された場合、分岐予測は単純なダイレクトマップされた1ビットBTBを使用して行われます。  BTB
のエントリは、単純なデュアルポート分散RAM（LUTRAM）に格納されます。
をサポートするアーキテクチャでは、BTBエントリは単純なデュアルポート分散RAM（LUTRAM）に格納されるため、過剰なサイズに設定するべきではありません。
(現在、最大64エントリに制限されています)。  アーキテクチャが分散型RAMをサポートしていない場合
をサポートしていない場合は、フリップフロップが使用されるため、BTB
のエントリ数は1桁台前半に抑える必要があります。

### MULTIPLY_ENABLE` (デフォルト = 0)

ハードウェア乗算を有効にします。  0に設定すると、乗算命令に対して不正な命令例外が発生します。
は乗算命令に対してスローされます。

### `DIVIDE_ENABLE` (デフォルト = 0 )

ハードウェア除算を有効にします（32サイクル/命令）。  0に設定すると、除算命令に対して不正な
命令例外が発生します。

### SHIFTER_MAX_CYCLES` (デフォルト = 1)

シフト操作にかかるサイクル数を指定し、値が小さいほど多くのロジックを使用します。
有効な値は、1、8、および32です。MULTIPLY_ENABLE`が1に設定されている場合、この設定オプションは無視されます。
は無視され、シフターが乗算器を使用します。

### Power_OPTIMIZED` (デフォルト = 0)

このオプションを 1 に設定すると、電力消費を改善するために余分なゲートが追加されます。
面積と最大倍率を犠牲にして、電力消費を改善するために余分なゲートが追加されます。

### ENABLE_EXCEPTIONS` (デフォルト = 1)

この値を1に設定すると、プロセッサが不正な命令トラップとmret命令をサポートできるようにするためのロジックが追加されます。
不正な命令トラップやmret命令をサポートするためのロジックが追加されます。  外部割り込みが必要な場合
外部割り込みが必要な場合は、`ENABLE_EXT_INTERRUPTS`と同様に1に設定する必要があります。

### パイプラインステージ(PIPELINE_STAGES) ( デフォルト = 5)

有効な値は、4と5です。4 に設定すると、レジスタファイルの出力側のレジスタが削除されます。
レジスタファイルの出力側のレジスタを削除し、最大周波数を犠牲にして領域を節約します。

### VCP_ENABLE` (デフォルト=0)

Vector Coprocessor Port (VCP)を有効にします。このポートはVectorBlox独自のLightweight Vector Extensions (VCP)に接続します。
VectorBlox 独自の Lightweight Vector Extensions (LVE) または Matrix Processor (MXP)に接続します。  A
1ではVCP命令の32ビット版が有効になり、2では32ビットと64ビットの両方が有効になります。
2を指定すると、32ビットと64ビットの両方のVCP命令が有効になります。

### ENABLE_EXT_INTERRUPTS` (デフォルト=0)

外界からの割り込みがプロセッサに割り込むことを有効にします。
これを1に設定する場合は`ENABLE_EXCEPTIONS`を1に設定する必要があります。

### `NUM_EXT_INTERRUPTS` (デフォルト = 1)

ENABLE_EXT_INTERRUPTS` を 1 に設定した場合、いくつの割り込みをサポートするか選択します。
サポートします。

### `FAMILY` (デフォルト = GENERIC)

特定のFPGAファミリーを使用する際に、特定の移植性の回避策と最適化を有効にします。
特定のFPGAファミリーを使用する場合に、特定の移植性の回避策と最適化を有効にします。  現在、"GENERIC"、"INTEL"、"LATTICE"、"MICROSEMI"、および "XILINX "がサポートされています。
がサポートされています。


External MTIME(H) Counter
----------------------

RISC-Vでは、MTIME/MTIMEH CSRはメモリマップレジスタのシャドウであることが規定されています。
レジスタのシャドウであることを規定しています。  これを柔軟に実装できるようにするために、我々は
MTIME/MTIMEHカウンタとタイマ割り込みを外部コンポーネント(ORCA Timer)として実装しました。
として実装しており、ip/orca-timerディレクトリにあります。  QsysおよびVivado用ラッパー
ORCAタイマ・コンポーネントのIPIも提供されています。

これにより、非常に小さな実装でも、64ビットより小さいカウンタやカウンタを実装することでスペースを節約することが可能になります。
64ビットより小さいカウンターを実装したり、メモリマップインターフェイスを廃止して
メモリマップインターフェイスを排除し、代わりにフリーランニングカウンターを使用することで、非常に小さな実装でスペースを節約することができます。


Memory Interfaces
----------------------

ORCAは、異なるFPGA IPと相互運用するために、複数のメモリ・インタフェースをサポートしています。
アクセスは、キャッシュ（キャッシュが有効な場合）またはキャッシュされない場合があります。  キャッシュされた命令
またはデータ・アクセスは、それぞれICまたはDC AXIインタフェースを介して出力されます。  キャッシュなし
アクセスは、キャッシュされていない AXI4-Lite (IUC/DUC) または補助インターフェイス (WISHBONE、Avalue) のいずれかに送られます。
(WISHBONE、Avalon、またはLMB)のいずれかを使用します。

どのメモリ・インターフェイスを使用するかは、オプションの Auxiliarly Memory Region (AMR) と Uncached Memory Region (LMB) の値によって決まります。
メモリ領域 (AMR) とキャッシュされていないメモリ領域 (UMR) CSR の値に依存します。  AMRが最も優先されます。
AMRは最も優先度が高く、1つ以上のAMRがインスタンス化されている場合（`AUX_MEMORY_CSR'を設定することにより
AMRは最も優先度が高く、1つ以上のAMRがインスタンス化されていて（`AUX_MEMORY_REGIONS`ジェネリックを1以上に設定する）、アクセスされるアドレスが`AMR'以上であれば
AMRx_ADDR_BASE`以上であり、`AMRx_ADDR_BASE`以下である。
AMRx_ADDR_LAST`以上、AMRx_ADDR_LAST`以下である場合、補助メモリインターフェイスを使用することになります。
インターフェイスを使用します。  これらは包括的なものであるため、AMRを無効にするには、ベースアドレスを
AMRを無効にするには、ベースアドレスを最後のアドレスより大きく設定する必要があります。  UMRは次に高い優先度を持ち
UMRは次に優先度が高く、AMRと同じように機能します。  最後に、アクセスが以下のいずれにも一致する場合
最後に、アクセスがAMRとUMRのどちらにもマッチしない場合、そのアクセスはキャッシュにヒットしようとします（もし、`ICACH'を設定してインスタンス化された場合、そのアクセスはキャッシュにヒットしようとします。
ICACHE_SIZE`/`DCACHE_SIZE`ジェネリックを0でないように設定することでインスタンス化されます）。
をゼロ以外の値に設定することでインスタンス化される場合)。  キャッシュは現在、ライトスルーのみをサポートしており、ライトミス時の割り当てはありません。
しかし、将来的には他のモードもサポートされる予定です。

|**CSR Name**     | **CSR Number** | **Access**|
|:----------------|:--------------:|:---------:|
|`CSR_MAMR0_BASE` | 0xBD0          | RW        |
|`CSR_MAMR1_BASE` | 0xBD1          | RW        |
|`CSR_MAMR2_BASE` | 0xBD2          | RW        |
|`CSR_MAMR3_BASE` | 0xBD3          | RW        |
|`CSR_MAMR0_LAST` | 0xBD8          | RW        |
|`CSR_MAMR1_LAST` | 0xBD9          | RW        |
|`CSR_MAMR2_LAST` | 0xBDA          | RW        |
|`CSR_MAMR3_LAST` | 0xBDB          | RW        |
|`CSR_MUMR0_BASE` | 0xBE0          | RW        |
|`CSR_MUMR1_BASE` | 0xBE1          | RW        |
|`CSR_MUMR2_BASE` | 0xBE2          | RW        |
|`CSR_MUMR3_BASE` | 0xBE3          | RW        |
|`CSR_MUMR0_LAST` | 0xBE8          | RW        |
|`CSR_MUMR1_LAST` | 0xBE9          | RW        |
|`CSR_MUMR2_LAST` | 0xBEA          | RW        |
|`CSR_MUMR3_LAST` | 0xBEB          | RW        |


通常、AMRやUMRは、CSRの書き込みによって実行時に変更することができます。  しかし、もし
命令キャッシュもデータキャッシュも指定されておらず、`AUX_MEMORY_REGIONS`が0以外、`UC_MEMORY_REGIONS`が0である場合、すべてのアクセスは補助キャッシュを経由する。
が0でなく、`UC_MEMORY_REGIONS`が0である場合、すべてのアクセスは補助インターフェースを経由して行われます。
を経由し、AMRは領域節約のため無効化されます。  同様に、キャッシュがない場合
で、`UC_MEMORY_REGIONS`が0以外、`AUX_MEMORY_REGIONS`が0に設定されています。
を0に設定すると、すべてのアクセスはキャッシュされていないインターフェイスを経由し、すべてのUMRが無効になります。
無効化されたAMR/UMRは、読み込み時に0を返し、書き込みはできません。

ORCAはキャッシュアクセスにAXI3またはAXI4を使用し、キャッシュされないアクセスにはAXI4-Liteを使用します。
しかし、システム構築ツールによってはAXI3マスターが必要なため、すべてのインターフェイスでAXI3マスターを公開します。
が必要なためです。  キャッシュされたマスターにAXI4インターフェースを使用するには、次のように設定します。
LOG2_BURSTLENGTH`を8（AXI3は4）に設定し、WID信号を接続しない。  使用する場合
AXI4-Liteインターフェースをキャッシュされていないマスターに使用する場合は、AXI4-Lite信号のみを接続します。
信号のみを接続し、残りは接続せずに安全です。


ORCA Memory Generics
----------------------

### `log2_burstlength`.

キャッシュアクセスに使用されるバーストレングスの基数2の対数（キャッシュが有効な場合、効果はありません
キャッシュが有効でない場合は影響しません）。

### `axi_id_width` (axi_id_width)。

すべてのAXIインターフェイスのAXI ID幅。  ORCAでは複数のAXI IDを使用しません。
(xID信号は常に0に設定されます); この一般的なものは、単にマスターからのID信号を必要とするインターフェースのために存在します。
マスターからのID信号が必要なインターフェースのために存在します。

### `(アバロン/LMB/ウィッシュボーン)_aux`。

3つのジェネリック（`AVALON_AUX`、`LMB_AUX`、`WISHBONE_AUX`）があります。
補助メモリ・インターフェースが使用するプロトコルを選択します。
を1つに設定する必要があります。  Intel Qsysでは、これは公開されておらず、Avalonが有効になっています、
同様に、Xilinx Vivado IPIでは、これは公開されず、LMBが有効になります。  これらは
補助メモリインターフェイスが使用されない場合、これらは安全に無視できます。
(`AUX_MEMORY_REGIONS`を0に設定)。

### `(aux/uc)_memory_regions` です。

補助/非キャッシュメモリー領域と対応するAMR/UMRの数です；
詳細については、上記の「メモリインターフェース」のセクションを参照してください。

### 詳細は上記のメモリインターフェイスのセクションを参照してください。

最初のAMR/UMR CSRの初期値です。  これらは、ジェネリックで設定することができます。
一般的なケースとして、単一の連続する WISHBONE/Avalon/LMB
インターフェイス、およびペリフェラルとオンチップメモリのための単一の連続したキャッシュされていないインターフェイスが必要な場合に、ジェネリックで設定できます。
オンチップメモリのための単一の連続したキャッシュされていないインタフェース。  複数の非連続領域が必要な場合、それらは実行時に設定する必要があります。
実行時に設定する必要があります。

### (icache/dcache)_size`を指定します。

命令キャッシュとデータキャッシュのサイズをバイト数で指定します。  0に設定するとキャッシュが無効になります。
0に設定するとキャッシュを無効にします。各キャッシュは異なるサイズにすることができ、必要に応じて命令キャッシュのみ、データキャッシュのみを使用することができます。
各キャッシュは異なるサイズにすることができ、必要に応じて命令キャッシュのみまたはデータキャッシュのみを使用することが可能です。  キャッシュが有効かどうかを判断するためのCSRがあります。
キャッシュが有効かどうかを判断するためのCSRがあります：CSR_MCACHE`です。

|**CSR Name** | **CSR Number** | **Access**|
|:------------|:--------------:|:---------:|
|`CSR_MCACHE` | 0xBC0          | RO        |

命令キャッシュが有効な場合はビット0が、データキャッシュが有効な場合はビット1が設定されます。
が有効になります。

### `dcache_writeback` です。

データキャッシュの書き込みポリシー。  ライトスルーの場合は 0、ライトバックの場合は 1 に設定します。
ライトスルーでは、すべての書き込みを即座にDCバスに置き、書き込みミス時に割り当てない。
書き込み失敗時に割り当てない。  ライトバックは、ダーティキャッシュラインを退避時に書き戻す。
(競合、IFENCE、またはFLUSH/INVALIDATE）、および書き込みミス時に割り当てを行います。

### `(icache/dcache)_line_size` です。

命令キャッシュとデータキャッシュのキャッシュラインのサイズ（バイト単位）。

### `(icache/dcache)_external_width`

命令キャッシュとデータキャッシュの外部メモリインターフェイスのビット単位のサイズ。
キャッシュの外部メモリインターフェイスのビットサイズ。

### `(命令/データ)_(リクエスト/リターン)_レジスタ`。

メモリアクセスにレイテンシを追加することを犠牲にして、最大周波数を増加させるためのレジスタ。
メモリアクセスにレイテンシーを追加する代償として、最大周波数を増加させるためのレジスタです。  これらは、すべての命令またはデータアクセス（キャッシュヒットを含む）に影響します。
キャッシュヒットを含む)に影響を及ぼしますが、以下の一般的なものはインターフェイス単位です。

REQUESTレジスタは、マスターからスレーブへの送信経路に影響します（読み出しと書き込み）。
と書き込み）。  0は「無効」、1は「ライト」、2は「フル」に設定することができます。
full」に設定することができます。  ライトレジスタは、インターフェイスがバックプレッシャーをかけず、コンバインを分離する場合、レイテンシを追加することはありません。
クリティカルパスであることが多いREADY/waitrequest信号を介して、インターフェイスが背圧をかけず、組合せパスを分離する場合は、ライトレジスタはレイテンシーを追加しません。
信号で結合パスを分離します。  フル・レジスタは、常に1サイクルのレイテンシを追加します。
しかし、インターフェイスがバックプレッシャーをかけ、コンバイナリー・パスを分離した場合、スループットは完全に維持されます。
をかけ、全信号を通じて組合せ経路を分離します。

RETURNレジスタは、リード時にスレーブからマスターにデータを戻すのに影響します。
読み出し時にスレーブからマスタにデータを戻すことに影響します。  これらは、「disabled」の場合は0、「enabled」の場合は1に設定することしかできません。
有効にすると、読み出しに1サイクルのレイテンシーが追加されます。

周波数を上げるために命令レジスタが必要な場合は、必ず「MAX_IFETCHES」を設定してください。
MAX_IFETCHES_IN_FLIGHT`ジェネリックを、少なくとも命令フェッチパスの全レイテンシに設定してください。
フェッチパスの全レイテンシ以上にしてください。  例えば、完全な命令要求レジスタを使用する場合、次のようになります。
(INSTRUCTION_REQUEST_REGISTER`は2に設定)と命令リターンレジスタ
(INSTRUCTION_RETURN_REGISTER`を1に設定)すると、命令フェッチに2サイクルの遅延が追加されます。
命令フェッチに2サイクルの遅れが生じます。  このため、1サイクルのオンチップRAMに接続した場合でも、すべての命令フェッチに3サイクルかかります。
すべての命令フェッチに3サイクルを要することになります。  このような場合
MAX_IFETCHES_IN_FLIGHT`を3に設定してもORCAは1命令あたり1サイクルで動作することが可能です。
(分岐予測ミス、ロードレイテンシ、マルチサイクル命令などを除けば)ORCAは1命令あたり1サイクルで動作します。
一方、`MAX_IFETCHES_IN_FLIGHT`を1に設定した場合は、1命令あたり3サイクルしか実行できません。
を1に設定した場合は、せいぜい1命令あたり3サイクルで実行できる程度です。

### (i/d)(uc/aux/c)_(request/return)_register`。

インターフェイス固有のメモリインターフェイスレジスタです。  具体的には、上記の一般的な説明を参照してください。
を参照してください。  なお、キャッシュされた
(IC/DC)_(REQUEST/RETURN)_REGISTER`レジスタはキャッシュマスターに適用されるので
キャッシュマスターに適用されるため、キャッシュミスのときのみ使用されます。
(INSTRUCTION/DATA)_(REQUEST/RETURN)_REGISTER`レジスタはORCAコアとキャッシュの間にあるため、キャッシュミス時にのみ使用されます。
コアとキャッシュの間にあるため、キャッシュヒットにも影響します。


Interrupts
----------------------

特権仕様書V1.9に記載されているPLIC(Platform Level Interrupt Controller)は、私たちのニーズには複雑すぎることがわかりました。
私たちのニーズには複雑すぎたので、ORCAには非標準の非常にシンプルな割り込みコントローラがあります。
は、非標準的だが非常にシンプルな割り込みコントローラを採用している。

我々はさらに2つの32ビットCSR、`MEIPEND`と`MEIMASK`を定義します。これらのレジスタは
は最大32ビット幅なので、ORCAはネイティブで32個の割り込みしかサポートしません。
MEIMASK`は外部割り込みのマスクである。  MEIMASK`のビット*n*がセットされている場合、その*n番目の割り込みが発生します。
がセットされている場合、*n*番目の割り込みが有効になります。  MEIPEND`は、MEIMASKに接続されています。
external interrupt lines, and as such is read-only.

|**CSR Name** | **CSR Number** | **Access**|
|:------------|:--------------:|:---------:|
|MEIMASK      | 0x7C0          |  RW       |
|MEIPEND      | 0xFC0          |  RO       |

以下の場合に限り、プロセッサーはライン*n*の外部割り込みによって中断されます。
MSTATUS`CSRの`MIE`ビットが1であり、`MEIMASK`CSRのビット*n*が1に設定されている場合。
割り込みはレベルセンシティブでアクティブハイであるため、割り込みハンドラの責任でクリアする必要があります。
そのため、割り込みハンドラは割り込みをクリアする責任があります（一般に、担当する周辺回路と通信することによって）。
そのため、割り込みハンドラの責任として、割り込みをクリアしてから（一般的には、メモリマップドI/Oを介して担当のペリフェリアと通信して
MIE`ビットを再び有効にする。  MIE`ビットがリセットされたとき、割り込み線がまだハイになっている場合（通常、MIE`ビットを介して）。
ビットがリセットされたとき（一般的にはmret命令で）、割り込み線がまだハイであれば、割り込みは直ちに再び発生します。
がリセットされると、割り込みは再び発生します。

割り込みが有効になっていない場合（`ENABLE_EXT_INTERRUPTS`が0に設定されているか、または
ENABLE_EXCEPTIONS`が0に設定されている）、`MEIMASK`と`MEIPEND`はどちらも読み取り専用で0を返します。
のみで、0を返します。
